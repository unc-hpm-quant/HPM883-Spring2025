{
  "hash": "4a73ec895e9a0c06ae8418d026d537c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Optimal Experiment Design App\"\nformat: html\nruntime: shiny_prerendered\n---\n\n::: {.cell context='setup'}\n\n```{.r .cell-code}\nlibrary(shiny)\n```\n:::\n\n\n#| panel: sidebar\n  \n  titlePanel(\"Optimal Experimental Design for One Treatment vs. One Control\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      # --- Choose outcome type (binary or continuous)\n      radioButtons(\n        inputId = \"outcomeType\", \n        label = \"Outcome Type\",\n        choices = c(\"Binary\" = \"binary\", \"Continuous\" = \"continuous\"),\n        selected = \"continuous\"\n      ),\n      \n      # --- Significance level (alpha)\n      sliderInput(\n        inputId = \"alpha\", \n        label = \"Significance level (alpha):\",\n        min = 0.001, \n        max = 0.10, \n        step = 0.001,\n        value = 0.05\n      ),\n      \n      # --- Power (1 - beta)\n      sliderInput(\n        inputId = \"power\", \n        label = \"Statistical Power (1 - beta):\",\n        min = 0.50, \n        max = 0.99, \n        step = 0.01,\n        value = 0.80\n      ),\n      \n      # --- Parameters for continuous outcome\n      conditionalPanel(\n        condition = \"input.outcomeType == 'continuous'\",\n        numericInput(\"sigmaT\", \"Treatment Variance (σ²_T):\", 1),\n        numericInput(\"sigmaC\", \"Control Variance (σ²_C):\", 1)\n      ),\n      \n      # --- Parameters for binary outcome\n      conditionalPanel(\n        condition = \"input.outcomeType == 'binary'\",\n        sliderInput(\"pT\", \"Treatment proportion (p_T):\",\n                    min = 0, max = 1, step = 0.01, value = 0.3),\n        sliderInput(\"pC\", \"Control proportion (p_C):\",\n                    min = 0, max = 1, step = 0.01, value = 0.3)\n      ),\n      \n      # --- Allocation: either fix total sample size or total cost\n      radioButtons(\n        inputId = \"constraintType\",\n        label = \"Constraint Type:\",\n        choices = c(\"Fixed Total Sample Size\" = \"sample\",\n                    \"Fixed Total Cost\"        = \"cost\")\n      ),\n      \n      # --- If total sample size is the constraint\n      conditionalPanel(\n        condition = \"input.constraintType == 'sample'\",\n        numericInput(\"N\", \"Total Sample Size (N):\", 200, min = 2, step = 1)\n      ),\n      \n      # --- If total cost is the constraint\n      conditionalPanel(\n        condition = \"input.constraintType == 'cost'\",\n        numericInput(\"costT\", \"Cost per Treatment Unit:\", 2, min = 1, step = 1),\n        numericInput(\"costC\", \"Cost per Control Unit:\", 1, min = 1, step = 1),\n        numericInput(\"budget\", \"Total Budget:\", 300, min = 1, step = 1)\n      ),\n      \n      # --- Option to let the user pick ratio or find optimum\n      radioButtons(\n        inputId = \"ratioChoice\",\n        label = \"Allocation Choice:\",\n        choices = c(\"Manually Pick Ratio\" = \"manual\",\n                    \"Find Optimal Ratio\"  = \"optimal\")\n      ),\n      \n      sliderInput(\n        inputId = \"ratio\",\n        label = \"Treatment:Control Ratio (r = n_T / n_C):\",\n        min = 0.1,\n        max = 10,\n        step = 0.1,\n        value = 1\n      )\n    ),\n    \n    mainPanel(\n      tabsetPanel(\n        tabPanel(\"MDE vs. Ratio\", \n                 plotOutput(\"plotMDE\"),\n                 br(),\n                 verbatimTextOutput(\"textResult\")\n        ),\n        tabPanel(\"Cost Allocation Plot\",\n                 plotOutput(\"plotCost\", height = \"500px\"),\n                 helpText(\"This plot shows the budget constraint line \",\n                          \"and iso-MDE curves for different cost allocations \",\n                          \"(c_C on the x-axis, c_T on the y-axis). \",\n                          \"The red point indicates the optimal allocation \",\n                          \"where MDE is minimized, if available.\")\n        )\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  \n  # Helper: z-value for alpha/2 (two-sided) and for power\n  zAlpha <- reactive({\n    qnorm(1 - input$alpha / 2)\n  })\n  zBeta <- reactive({\n    # For power (1 - beta), we want zBeta = z_{1 - beta}\n    # i.e., the critical value for the upper tail\n    qnorm(input$power)\n  })\n  \n  # Function to compute MDE given n_C, n_T (the sample sizes)\n  computeMDE_from_n <- function(nC, nT) {\n    if (input$outcomeType == \"continuous\") {\n      sigmaT <- input$sigmaT\n      sigmaC <- input$sigmaC\n      varTerm <- sigmaT^2 / nT + sigmaC^2 / nC\n    } else {\n      pT <- input$pT\n      pC <- input$pC\n      varTerm <- pT*(1 - pT)/nT + pC*(1 - pC)/nC\n    }\n    (zAlpha() + zBeta()) * sqrt(varTerm)\n  }\n  \n  # Function to compute MDE given a ratio (for either sample or cost constraint)\n  computeMDE_ratio <- function(r) {\n    # 1) Determine n_T and n_C based on constraints and ratio\n    if (input$constraintType == \"sample\") {\n      # n_T + n_C = N, and n_T / n_C = r\n      n_C <- input$N / (r + 1)\n      n_T <- r * n_C\n    } else {\n      # costT * n_T + costC * n_C = budget, n_T / n_C = r\n      # => n_T = r * n_C\n      # => costT * (r * n_C) + costC * n_C = budget\n      # => n_C (r*costT + costC) = budget\n      n_C <- input$budget / (r * input$costT + input$costC)\n      n_T <- r * n_C\n    }\n    \n    # 2) Compute MDE\n    computeMDE_from_n(n_C, n_T)\n  }\n  \n  # Plot: MDE vs. ratio\n  output$plotMDE <- renderPlot({\n    # We'll vary r from 0.1 to 10 in increments of 0.1\n    rVals <- seq(0.1, 10, by = 0.1)\n    mdeVals <- sapply(rVals, computeMDE_ratio)\n    \n    plot(rVals, mdeVals, type = \"l\", lwd = 2, \n         xlab = \"Ratio (n_T / n_C)\", ylab = \"MDE\",\n         main = \"Minimum Detectable Effect vs. Allocation Ratio\")\n    \n    # If in manual mode, highlight user's chosen ratio\n    if (input$ratioChoice == \"manual\") {\n      rUser <- input$ratio\n      userMde <- computeMDE_ratio(rUser)\n      points(rUser, userMde, col = \"red\", pch = 19, cex = 1.5)\n    }\n  })\n  \n  # Text output: either user-chosen ratio or optimal ratio\n  output$textResult <- renderPrint({\n    if (input$ratioChoice == \"optimal\") {\n      # Find ratio that yields smallest MDE\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      idxMin <- which.min(mdeTest)\n      rOpt <- rTest[idxMin]\n      mdeOpt <- mdeTest[idxMin]\n      \n      if (input$constraintType == \"sample\") {\n        n_C_opt <- input$N / (rOpt + 1)\n        n_T_opt <- rOpt * n_C_opt\n      } else {\n        n_C_opt <- input$budget / (rOpt * input$costT + input$costC)\n        n_T_opt <- rOpt * n_C_opt\n      }\n      \n      cat(\"Optimal ratio (n_T / n_C):\", round(rOpt, 3), \"\\n\")\n      cat(\"Minimized MDE:\", round(mdeOpt, 4), \"\\n\")\n      cat(\"n_T:\", round(n_T_opt, 2), \"| n_C:\", round(n_C_opt, 2), \"\\n\")\n      \n    } else {\n      # Manual ratio\n      rUser <- input$ratio\n      mdeUser <- computeMDE_ratio(rUser)\n      \n      if (input$constraintType == \"sample\") {\n        n_C_user <- input$N / (rUser + 1)\n        n_T_user <- rUser * n_C_user\n      } else {\n        n_C_user <- input$budget / (rUser * input$costT + input$costC)\n        n_T_user <- rUser * n_C_user\n      }\n      \n      cat(\"User-chosen ratio (n_T / n_C):\", round(rUser, 3), \"\\n\")\n      cat(\"MDE at this ratio:\", round(mdeUser, 4), \"\\n\")\n      cat(\"n_T:\", round(n_T_user, 2), \"| n_C:\", round(n_C_user, 2), \"\\n\")\n    }\n  })\n  \n  # ------------------------------------------------------\n  #  NEW PLOT: Cost Allocation (c_C on x-axis, c_T on y-axis)\n  # ------------------------------------------------------\n  \n  output$plotCost <- renderPlot({\n    \n    # Only show this plot if user is in \"cost\" constraint AND\n    # ratio choice is \"optimal\" (because we want to show the tangency)\n    # But we can still show some helpful info if user is in \"manual\" mode, too.\n    if (input$constraintType != \"cost\") {\n      plot.new()\n      text(0.5, 0.5, \"Cost Allocation Plot is only relevant for a cost constraint.\")\n      return(NULL)\n    }\n    \n    # We'll define a grid for c_C and c_T:\n    # Let c_C range from 0 to budget, let c_T range from 0 to budget\n    # feasible region is c_C + c_T <= budget.\n    budget <- input$budget\n    cC_vals <- seq(0, budget, length.out = 50)\n    cT_vals <- seq(0, budget, length.out = 50)\n    \n    # We'll compute MDE for each (c_C, c_T), provided it's feasible.\n    # c_C = costC * n_C => n_C = c_C / costC\n    # c_T = costT * n_T => n_T = c_T / costT\n    # Then MDE = (zAlpha + zBeta) * sqrt(...).\n    \n    costC <- input$costC\n    costT <- input$costT\n    \n    # Create a matrix for storing MDE\n    MDE_matrix <- matrix(NA, nrow = length(cC_vals), ncol = length(cT_vals))\n    \n    for (i in seq_along(cC_vals)) {\n      for (j in seq_along(cT_vals)) {\n        cC <- cC_vals[i]\n        cT <- cT_vals[j]\n        # Feasibility check:\n        if (cC + cT <= budget) {\n          nC <- cC / costC\n          nT <- cT / costT\n          # avoid zero or negative nC,nT\n          if (nC > 0 & nT > 0) {\n            MDE_matrix[i, j] <- computeMDE_from_n(nC, nT)\n          } else {\n            MDE_matrix[i, j] <- NA\n          }\n        } else {\n          MDE_matrix[i, j] <- NA\n        }\n      }\n    }\n    \n    # We'll make a filled contour or contour plot of MDE\n    # But first we want a minimal MDE for labeling\n    # (We can just find the min ignoring NAs.)\n    minMDE <- min(MDE_matrix, na.rm = TRUE)\n    maxMDE <- max(MDE_matrix, na.rm = TRUE)\n    \n    # Basic contour plot. We show c_C on x-axis, c_T on y-axis\n    contour(\n      x = cC_vals, y = cT_vals, z = MDE_matrix, \n      levels = pretty(seq(minMDE, maxMDE, length.out = 10)), \n      col = \"blue\", \n      xlab = \"Cost allocated to Control (c_C)\", \n      ylab = \"Cost allocated to Treatment (c_T)\",\n      main = \"Iso-MDE Curves and Budget Constraint\"\n    )\n    \n    # Add the budget line: c_T = budget - c_C\n    lines(cC_vals, budget - cC_vals, col = \"red\", lwd = 2)\n    \n    # If user is in \"optimal\" ratio mode, we find the optimum point and plot it\n    if (input$ratioChoice == \"optimal\") {\n      # We already find that ratio in textResult, but let's do it again here\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      idxMin <- which.min(mdeTest)\n      rOpt <- rTest[idxMin]\n      \n      # Compute cC_opt and cT_opt at that ratio\n      # budget = costT*n_T + costC*n_C\n      # n_T / n_C = r => n_T = r*n_C\n      # => costT*(r*n_C) + costC*n_C = budget\n      # => n_C(r*costT + costC) = budget\n      # => n_C = budget / (r*costT + costC)\n      nC_opt <- budget / (rOpt * costT + costC)\n      nT_opt <- rOpt * nC_opt\n      \n      # => c_C_opt = costC * n_C_opt\n      # => c_T_opt = costT * n_T_opt\n      cC_opt <- costC * nC_opt\n      cT_opt <- costT * nT_opt\n      \n      # Add that point to the plot\n      points(cC_opt, cT_opt, col = \"red\", pch = 19, cex = 1.5)\n    }\n  })\n}\n\npreserve024f4bcaa76d57ed\npreserveb28927330c870678\n\n<!--html_preserve-->\n<script type=\"application/shiny-prerendered\" data-context=\"dependencies\">\n{\"type\":\"list\",\"attributes\":{},\"value\":[]}\n</script>\n<!--/html_preserve-->\n<!--html_preserve-->\n<script type=\"application/shiny-prerendered\" data-context=\"execution_dependencies\">\n{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"packages\"]}},\"value\":[{\"type\":\"list\",\"attributes\":{\"names\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"packages\",\"version\"]},\"class\":{\"type\":\"character\",\"attributes\":{},\"value\":[\"data.frame\"]},\"row.names\":{\"type\":\"integer\",\"attributes\":{},\"value\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]}},\"value\":[{\"type\":\"character\",\"attributes\":{},\"value\":[\"base\",\"cli\",\"compiler\",\"datasets\",\"digest\",\"evaluate\",\"fastmap\",\"graphics\",\"grDevices\",\"htmltools\",\"htmlwidgets\",\"httpuv\",\"jsonlite\",\"knitr\",\"later\",\"lifecycle\",\"magrittr\",\"methods\",\"mime\",\"promises\",\"R6\",\"Rcpp\",\"renv\",\"rlang\",\"rmarkdown\",\"shiny\",\"stats\",\"tools\",\"utils\",\"xfun\",\"xtable\",\"yaml\"]},{\"type\":\"character\",\"attributes\":{},\"value\":[\"4.4.1\",\"3.6.3\",\"4.4.1\",\"4.4.1\",\"0.6.37\",\"1.0.3\",\"1.2.0\",\"4.4.1\",\"4.4.1\",\"0.5.8.1\",\"1.6.4\",\"1.6.15\",\"1.8.9\",\"1.49\",\"1.4.1\",\"1.0.4\",\"2.0.3\",\"4.4.1\",\"0.12\",\"1.3.2\",\"2.5.1\",\"1.0.14\",\"1.1.0\",\"1.1.5\",\"2.29\",\"1.10.0\",\"4.4.1\",\"4.4.1\",\"4.4.1\",\"0.50\",\"1.8-4\",\"2.3.10\"]}]}]}\n</script>\n<!--/html_preserve-->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {
      "preserve024f4bcaa76d57ed": "\n<script type=\"application/shiny-prerendered\" data-context=\"server-start\">\nlibrary(shiny)\n</script>\n",
      "preserveb28927330c870678": "\n<script type=\"application/shiny-prerendered\" data-context=\"server-extras\">\nojs_define <- function(..., .session = shiny::getDefaultReactiveDomain()) {\n  quos <- rlang::enquos(...)\n  vars <- rlang::list2(...)\n  nm <- names(vars)\n  if (is.null(nm)) {\n    nm <- rep_len(\"\", length(vars))\n  }\n  mapply(function(q, nm, val) {\n    # Infer name, if possible\n    if (nm == \"\") {\n      tryCatch({\n        nm <- rlang::as_name(q)\n      }, error = function(e) {\n        code <- paste(collapse = \"\\n\", deparse(rlang::f_rhs(q)))\n        stop(\"ojs_define() could not create a name for the argument: \", code)\n      })\n    }\n    .session$output[[nm]] <- val\n    outputOptions(.session$output, nm, suspendWhenHidden = FALSE)\n    .session$sendCustomMessage(\"ojs-export\", list(name = nm))\n    NULL\n  }, quos, nm, vars, SIMPLIFY = FALSE, USE.NAMES = FALSE)\n  invisible()\n}\n</script>\n"
    },
    "postProcess": true
  }
}