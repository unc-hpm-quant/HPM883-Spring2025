[{"name":"app.R","content":"library(shiny)\nlibrary(ggplot2)\n\nui <- fluidPage(\n  titlePanel(\"Optimal Experimental Design for One Treatment vs. One Control\"),\n  \n  # Add help text at the top\n  fluidRow(\n    column(12,\n      h4(\"Understanding Power Analysis and Optimal Design\"),\n      p(\"This app helps you determine optimal sample sizes and allocation ratios for experiments.\",\n        \"The calculations consider both statistical power and practical constraints.\"),\n      p(\"Key concepts:\"),\n      tags$ul(\n        tags$li(strong(\"Minimum Detectable Effect (MDE):\"), \n               \"The smallest true effect size that your study can reliably detect with the specified power.\"),\n        tags$li(strong(\"Optimal Allocation:\"), \n               \"The best way to divide participants between treatment and control groups, considering:\",\n               tags$ul(\n                 tags$li(\"Statistical efficiency (minimizing MDE)\"),\n                 tags$li(\"Cost constraints\"),\n                 tags$li(\"Practical implementation\"))\n               ),\n        tags$li(strong(\"Power vs. Sample Size:\"), \n               \"There's always a trade-off - higher power requires larger samples.\")\n      ),\n      p(\"Adjust the parameters below to explore how different choices affect your study design.\"),\n      tags$hr()\n    )\n  ),\n  \n  sidebarLayout(\n    sidebarPanel(\n      # --- Choose outcome type (binary or continuous)\n      radioButtons(\n        inputId = \"outcomeType\", \n        label = \"Outcome Type\",\n        choices = c(\"Binary\" = \"binary\", \"Continuous\" = \"continuous\"),\n        selected = \"continuous\"\n      ),\n      div(class = \"well\",\n        h5(\"Outcome Types:\"),\n        p(strong(\"Binary Outcomes:\"),\n          \"Measured as proportions or percentages (e.g., success rates, mortality rates).\",\n          \"The variance is determined by the proportion itself - highest at p=0.5.\"),\n        p(strong(\"Continuous Outcomes:\"),\n          \"Measured on a continuous scale (e.g., blood pressure, test scores).\",\n          \"Requires estimates of population variance in each group.\")\n      ),\n      \n      # --- Significance level (alpha)\n      sliderInput(\n        inputId = \"alpha\", \n        label = \"Significance level (alpha):\",\n        min = 0.001, \n        max = 0.10, \n        step = 0.001,\n        value = 0.05\n      ),\n      div(class = \"well\",\n        h5(\"Significance Level (α):\"),\n        p(\"The probability of falsely concluding there is an effect when there isn't one (Type I error).\"),\n        tags$ul(\n          tags$li(strong(\"0.05 (5%)\"), \": Standard choice - 1 in 20 chance of false positive\"),\n          tags$li(strong(\"0.01 (1%)\"), \": More conservative - use for critical decisions\"),\n          tags$li(strong(\"0.10 (10%)\"), \": More liberal - might use in pilot studies\")\n        )\n      ),\n      \n      # --- Power (1 - beta)\n      sliderInput(\n        inputId = \"power\", \n        label = \"Statistical Power (1 - beta):\",\n        min = 0.50, \n        max = 0.99, \n        step = 0.01,\n        value = 0.80\n      ),\n      div(class = \"well\",\n        h5(\"Statistical Power (1-β):\"),\n        p(\"The probability of detecting a true effect when it exists.\"),\n        tags$ul(\n          tags$li(strong(\"0.80 (80%)\"), \": Standard choice - accepts 20% chance of missing real effects\"),\n          tags$li(strong(\"0.90 (90%)\"), \": Higher power - use for critical studies, but requires larger samples\"),\n          tags$li(strong(\"0.70 (70%)\"), \": Lower power - might use in pilot studies or with resource constraints\")\n        ),\n        p(\"Remember: Increasing power requires larger sample sizes, often substantially.\")\n      ),\n      \n      # --- Parameters for continuous outcome\n      conditionalPanel(\n        condition = \"input.outcomeType == 'continuous'\",\n        numericInput(\"sigmaT\", \"Treatment Variance (σ²_T):\", 1),\n        numericInput(\"sigmaC\", \"Control Variance (σ²_C):\", 1),\n        helpText(\"The expected variances in each group. If unknown, assume equal variances.\")\n      ),\n      \n      # --- Parameters for binary outcome\n      conditionalPanel(\n        condition = \"input.outcomeType == 'binary'\",\n        sliderInput(\"pT\", \"Treatment proportion (p_T):\",\n                    min = 0, max = 1, step = 0.01, value = 0.3),\n        sliderInput(\"pC\", \"Control proportion (p_C):\",\n                    min = 0, max = 1, step = 0.01, value = 0.3),\n        helpText(\"The expected proportions in each group. For a new intervention,\",\n                 \"p_C might be known from historical data.\")\n      ),\n      \n      # --- Allocation: either fix total sample size or total cost\n      radioButtons(\n        inputId = \"constraintType\",\n        label = \"Constraint Type:\",\n        choices = c(\"Fixed Total Sample Size\" = \"sample\",\n                    \"Fixed Total Cost\"        = \"cost\")\n      ),\n      div(class = \"well\",\n        h5(\"Design Constraints:\"),\n        p(strong(\"Fixed Total Sample Size:\"),\n          \"Use when you have a specific total number of participants available.\",\n          \"The app will help you determine the optimal split between groups.\"),\n        p(strong(\"Fixed Total Cost:\"),\n          \"Use when you have a fixed budget and different costs per group.\",\n          \"Common when treatment is more expensive than control, or when recruitment costs differ.\")\n      ),\n      \n      # --- If total sample size is the constraint\n      conditionalPanel(\n        condition = \"input.constraintType == 'sample'\",\n        numericInput(\"N\", \"Total Sample Size (N):\", 200, min = 2, step = 1)\n      ),\n      \n      # --- If total cost is the constraint\n      conditionalPanel(\n        condition = \"input.constraintType == 'cost'\",\n        numericInput(\"costT\", \"Cost per Treatment Unit:\", 2, min = 1, step = 1),\n        numericInput(\"costC\", \"Cost per Control Unit:\", 1, min = 1, step = 1),\n        numericInput(\"budget\", \"Total Budget:\", 300, min = 1, step = 1)\n      ),\n      \n      # --- Option to let the user pick ratio or find optimum\n      radioButtons(\n        inputId = \"ratioChoice\",\n        label = \"Allocation Choice:\",\n        choices = c(\"Manually Pick Ratio\" = \"manual\",\n                    \"Find Optimal Ratio\"  = \"optimal\")\n      ),\n      \n      sliderInput(\n        inputId = \"ratio\",\n        label = \"Treatment:Control Ratio (r = n_T / n_C):\",\n        min = 0.1,\n        max = 10,\n        step = 0.1,\n        value = 1\n      )\n    ),\n    \n    mainPanel(\n      tabsetPanel(\n        tabPanel(\"MDE vs. Ratio\", \n                 plotOutput(\"plotMDE\"),\n                 br(),\n                 verbatimTextOutput(\"textResult\"),\n                 br(),\n                 h4(\"Step-by-Step Calculations\"),\n                 uiOutput(\"mdeCalcSteps\")\n        ),\n        tabPanel(\"Cost Allocation Plot\",\n                 plotOutput(\"plotCost\", height = \"500px\"),\n                 br(),\n                 h4(\"Step-by-Step Calculations\"),\n                 uiOutput(\"costCalcSteps\"),\n                 br(),\n                 helpText(\"This plot shows the budget constraint line \",\n                          \"and iso-MDE curves for different cost allocations \",\n                          \"(c_C on the x-axis, c_T on the y-axis). \",\n                          \"The red point indicates the optimal allocation \",\n                          \"where MDE is minimized, if available.\")\n        )\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  \n  # Helper: z-value for alpha/2 (two-sided) and for power\n  zAlpha <- reactive({\n    qnorm(1 - input$alpha / 2)\n  })\n  zBeta <- reactive({\n    qnorm(input$power)\n  })\n  \n  # Function to compute MDE given n_C, n_T (the sample sizes)\n  computeMDE_from_n <- function(nC, nT) {\n    if (input$outcomeType == \"continuous\") {\n      sigmaT <- input$sigmaT\n      sigmaC <- input$sigmaC\n      varTerm <- sigmaT^2 / nT + sigmaC^2 / nC\n    } else {\n      pT <- input$pT\n      pC <- input$pC\n      varTerm <- pT*(1 - pT)/nT + pC*(1 - pC)/nC\n    }\n    (zAlpha() + zBeta()) * sqrt(varTerm)\n  }\n  \n  # Function to compute MDE given a ratio (for either sample or cost constraint)\n  computeMDE_ratio <- function(r) {\n    # 1) Determine n_T and n_C based on constraints and ratio\n    if (input$constraintType == \"sample\") {\n      # n_T + n_C = N, and n_T / n_C = r\n      n_C <- input$N / (r + 1)\n      n_T <- r * n_C\n    } else {\n      # costT * n_T + costC * n_C = budget, n_T / n_C = r\n      n_C <- input$budget / (r * input$costT + input$costC)\n      n_T <- r * n_C\n    }\n    \n    # 2) Compute MDE\n    computeMDE_from_n(n_C, n_T)\n  }\n  \n  # Plot: MDE vs. ratio\n  output$plotMDE <- renderPlot({\n    # We'll vary r from 0.1 to 10 in increments of 0.1\n    rVals <- seq(0.1, 10, by = 0.1)\n    mdeVals <- sapply(rVals, computeMDE_ratio)\n    \n    plot(rVals, mdeVals, type = \"l\", lwd = 2, \n         xlab = \"Ratio (n_T / n_C)\", ylab = \"MDE\",\n         main = \"Minimum Detectable Effect vs. Allocation Ratio\")\n    \n    # If in manual mode, highlight user's chosen ratio\n    if (input$ratioChoice == \"manual\") {\n      rUser <- input$ratio\n      userMde <- computeMDE_ratio(rUser)\n      points(rUser, userMde, col = \"red\", pch = 19, cex = 1.5)\n    }\n  })\n  \n  # Helper function to format numbers nicely\n  format_num <- function(x) format(round(x, 4), nsmall = 4)\n  \n  # Text output: either user-chosen ratio or optimal ratio\n  output$textResult <- renderPrint({\n    if (input$ratioChoice == \"optimal\") {\n      # Find ratio that yields smallest MDE\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      idxMin <- which.min(mdeTest)\n      rOpt <- rTest[idxMin]\n      mdeOpt <- mdeTest[idxMin]\n      \n      if (input$constraintType == \"sample\") {\n        n_C_opt <- input$N / (rOpt + 1)\n        n_T_opt <- rOpt * n_C_opt\n      } else {\n        n_C_opt <- input$budget / (rOpt * input$costT + input$costC)\n        n_T_opt <- rOpt * n_C_opt\n      }\n      \n      cat(\"Optimal Allocation:\\n\")\n      cat(\"Optimal ratio (n_T / n_C):\", round(rOpt, 3), \"\\n\")\n      cat(\"Control group size (n_C):\", round(n_C_opt), \"\\n\")\n      cat(\"Treatment group size (n_T):\", round(n_T_opt), \"\\n\")\n      cat(\"Minimum Detectable Effect:\", round(mdeOpt, 3), \"\\n\")\n      \n    } else {\n      # User-chosen ratio\n      r <- input$ratio\n      mde <- computeMDE_ratio(r)\n      \n      if (input$constraintType == \"sample\") {\n        n_C <- input$N / (r + 1)\n        n_T <- r * n_C\n      } else {\n        n_C <- input$budget / (r * input$costT + input$costC)\n        n_T <- r * n_C\n      }\n      \n      cat(\"Current Allocation:\\n\")\n      cat(\"Ratio (n_T / n_C):\", round(r, 3), \"\\n\")\n      cat(\"Control group size (n_C):\", round(n_C), \"\\n\")\n      cat(\"Treatment group size (n_T):\", round(n_T), \"\\n\")\n      cat(\"Minimum Detectable Effect:\", round(mde, 3), \"\\n\")\n    }\n  })\n  \n  # Plot: Cost allocation\n  output$plotCost <- renderPlot({\n    # Only show this plot if user is in \"cost\" constraint\n    if (input$constraintType == \"cost\") {\n      # Generate grid of n_C, n_T values across full plot range\n      max_n_C <- input$budget/input$costC * 1.2  # Extend 20% beyond budget line\n      max_n_T <- input$budget/input$costT * 1.2\n      n_C <- seq(1, max_n_C, length.out = 100)\n      n_T <- seq(1, max_n_T, length.out = 100)\n      \n      # Create matrix of MDE values\n      mde_matrix <- matrix(NA, nrow = length(n_C), ncol = length(n_T))\n      for (i in 1:length(n_C)) {\n        for (j in 1:length(n_T)) {\n          mde_matrix[i,j] <- computeMDE_from_n(n_C[i], n_T[j])\n        }\n      }\n      \n      # Find optimal allocation\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      rOpt <- rTest[which.min(mdeTest)]\n      n_C_opt <- input$budget / (rOpt * input$costT + input$costC)\n      n_T_opt <- rOpt * n_C_opt\n      mde_opt <- computeMDE_from_n(n_C_opt, n_T_opt)\n      \n      # Create the plot\n      par(mar = c(5, 5, 4, 2))  # Increase margins for labels\n      \n      # Calculate reasonable MDE range for contours\n      min_mde <- max(min(mde_matrix, na.rm = TRUE), mde_opt * 0.8)  # Don't go too far below optimal\n      max_mde <- min(max(mde_matrix, na.rm = TRUE), mde_opt * 2.0)  # Don't show extremely large MDEs\n      \n      # Create evenly spaced levels, including the optimal MDE\n      contour_levels <- sort(unique(c(\n        seq(min_mde, max_mde, length.out = 8),  # 8 regular levels\n        mde_opt  # Include the optimal MDE level\n      )))\n      \n      # Plot contours\n      contour(n_C, n_T, mde_matrix, \n              xlab = \"Control Group Size (n_C)\",\n              ylab = \"Treatment Group Size (n_T)\",\n              main = \"Cost-constrained Allocation\",\n              levels = contour_levels,\n              labcex = 0.8,  # Slightly smaller contour labels\n              drawlabels = TRUE)\n      \n      # Add budget constraint line\n      budget_line_n_C <- seq(0, max_n_C, length.out = 100)\n      budget_line_n_T <- (input$budget - input$costC * budget_line_n_C) / input$costT\n      lines(budget_line_n_C, budget_line_n_T, col = \"red\", lwd = 2)\n      \n      # Add optimal MDE curve (the contour that passes through optimal point)\n      n_C_curve <- seq(1, max_n_C, length.out = 200)\n      n_T_curve <- numeric(length(n_C_curve))\n      for(i in 1:length(n_C_curve)) {\n        # Find n_T that gives the optimal MDE for this n_C\n        n_T_test <- seq(1, max_n_T, length.out = 200)\n        mde_test <- sapply(n_T_test, function(nt) computeMDE_from_n(n_C_curve[i], nt))\n        n_T_curve[i] <- n_T_test[which.min(abs(mde_test - mde_opt))]\n      }\n      lines(n_C_curve, n_T_curve, col = \"blue\", lwd = 2, lty = 2)\n      \n      # Add optimal point\n      points(n_C_opt, n_T_opt, col = \"red\", pch = 19, cex = 1.5)\n      \n      # Add legend for optimal MDE curve\n      legend(\"topright\", \n             legend = sprintf(\"Optimal MDE = %.3f\", mde_opt),\n             col = \"blue\", lwd = 2, lty = 2)\n    }\n  })\n  \n  # Render step-by-step MDE calculations\n  output$mdeCalcSteps <- renderUI({\n    # Get current values\n    if (input$ratioChoice == \"optimal\") {\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      r <- rTest[which.min(mdeTest)]\n    } else {\n      r <- input$ratio\n    }\n    \n    # Calculate sample sizes\n    if (input$constraintType == \"sample\") {\n      n_C <- input$N / (r + 1)\n      n_T <- r * n_C\n    } else {\n      n_C <- input$budget / (r * input$costT + input$costC)\n      n_T <- r * n_C\n    }\n    \n    # Calculate variances\n    if (input$outcomeType == \"continuous\") {\n      varT <- input$sigmaT^2\n      varC <- input$sigmaC^2\n      var_term <- varT/n_T + varC/n_C\n    } else {\n      varT <- input$pT * (1 - input$pT)\n      varC <- input$pC * (1 - input$pC)\n      var_term <- varT/n_T + varC/n_C\n    }\n    \n    # Critical values\n    z_alpha <- qnorm(1 - input$alpha/2)\n    z_beta <- qnorm(input$power)\n    \n    # Final MDE\n    mde <- (z_alpha + z_beta) * sqrt(var_term)\n    \n    # Create step-by-step explanation with LaTeX\n    tagList(\n      withMathJax(),\n      h4(\"Step-by-Step Calculations:\"),\n      \n      h5(\"1. Sample Size Calculation:\"),\n      if (input$constraintType == \"sample\") {\n        tagList(\n          p(sprintf(\"With total N = %d and ratio r = %.3f:\", input$N, r)),\n          withMathJax(sprintf(\"$$n_C = \\\\frac{N}{r + 1} = \\\\frac{%d}{%.3f + 1} = %.1f$$\", input$N, r, n_C)),\n          withMathJax(sprintf(\"$$n_T = r \\\\cdot n_C = %.3f \\\\cdot %.1f = %.1f$$\", r, n_C, n_T))\n        )\n      } else {\n        tagList(\n          p(sprintf(\"With budget = %d, c_T = %d, c_C = %d, and ratio r = %.3f:\", \n                    input$budget, input$costT, input$costC, r)),\n          withMathJax(sprintf(\"$$n_C = \\\\frac{\\\\text{budget}}{rc_T + c_C} = \\\\frac{%d}{%.3f \\\\cdot %d + %d} = %.1f$$\", \n                               input$budget, r, input$costT, input$costC, n_C)),\n          withMathJax(sprintf(\"$$n_T = r \\\\cdot n_C = %.3f \\\\cdot %.1f = %.1f$$\", r, n_C, n_T))\n        )\n      },\n      \n      h5(\"2. Variance Terms:\"),\n      if (input$outcomeType == \"continuous\") {\n        withMathJax(sprintf(\"$$\\\\sigma^2_T = %.3f, \\\\quad \\\\sigma^2_C = %.3f$$\", varT, varC))\n      } else {\n        tagList(\n          withMathJax(sprintf(\"$$\\\\text{Var}_T = p_T(1-p_T) = %.3f(1-%.3f) = %.3f$$\", input$pT, input$pT, varT)),\n          withMathJax(sprintf(\"$$\\\\text{Var}_C = p_C(1-p_C) = %.3f(1-%.3f) = %.3f$$\", input$pC, input$pC, varC))\n        )\n      },\n      withMathJax(sprintf(\"$$\\\\text{Combined variance} = \\\\frac{\\\\text{Var}_T}{n_T} + \\\\frac{\\\\text{Var}_C}{n_C} = \\\\frac{%.3f}{%.1f} + \\\\frac{%.3f}{%.1f} = %.4f$$\",\n                          varT, n_T, varC, n_C, var_term)),\n      \n      h5(\"3. Critical Values:\"),\n      withMathJax(sprintf(\"$$z_{1-\\\\alpha/2} = %.4f \\\\quad (\\\\text{for } \\\\alpha = %.3f)$$\", z_alpha, input$alpha)),\n      withMathJax(sprintf(\"$$z_{1-\\\\beta} = %.4f \\\\quad (\\\\text{for power } = %.3f)$$\", z_beta, input$power)),\n      \n      h5(\"4. Final MDE Calculation:\"),\n      withMathJax(\"$$\\\\text{MDE} = (z_{1-\\\\alpha/2} + z_{1-\\\\beta}) \\\\sqrt{\\\\frac{\\\\text{Var}_T}{n_T} + \\\\frac{\\\\text{Var}_C}{n_C}}$$\"),\n      withMathJax(sprintf(\"$$\\\\text{MDE} = (%.4f + %.4f) \\\\sqrt{%.4f} = %.4f$$\", \n                          z_alpha, z_beta, var_term, mde))\n    )\n  })\n  \n  # Render step-by-step cost allocation calculations\n  output$costCalcSteps <- renderUI({\n    if (input$constraintType != \"cost\") {\n      return(p(\"Step-by-step calculations are shown when using cost constraints.\"))\n    }\n    \n    # Get current optimal values if in optimal mode\n    if (input$ratioChoice == \"optimal\") {\n      rTest <- seq(0.1, 10, 0.01)\n      mdeTest <- sapply(rTest, computeMDE_ratio)\n      r <- rTest[which.min(mdeTest)]\n      n_C <- input$budget / (r * input$costT + input$costC)\n      n_T <- r * n_C\n      total_cost <- input$costT * n_T + input$costC * n_C\n      \n      tagList(\n        withMathJax(),\n        h4(\"Optimal Cost Allocation:\"),\n        \n        h5(\"1. Budget Constraint:\"),\n        withMathJax(sprintf(\"$$%d = %d n_T + %d n_C$$\", \n                           input$budget, input$costT, input$costC)),\n        \n        h5(\"2. Optimal Allocation Ratio:\"),\n        withMathJax(sprintf(\"$$r = \\\\frac{n_T}{n_C} = %.3f$$\", r)),\n        \n        h5(\"3. Sample Sizes:\"),\n        withMathJax(sprintf(\"$$n_C = \\\\frac{\\\\text{budget}}{rc_T + c_C} = \\\\frac{%d}{%.3f \\\\cdot %d + %d} = %.1f$$\",\n                           input$budget, r, input$costT, input$costC, n_C)),\n        withMathJax(sprintf(\"$$n_T = r \\\\cdot n_C = %.3f \\\\cdot %.1f = %.1f$$\", \n                           r, n_C, n_T)),\n        \n        h5(\"4. Cost Verification:\"),\n        withMathJax(sprintf(\"$$\\\\text{Total cost} = c_T n_T + c_C n_C = %d \\\\cdot %.1f + %d \\\\cdot %.1f = %d$$\",\n                           input$costT, n_T, input$costC, n_C, total_cost))\n      )\n    } else {\n      n_C <- input$budget / (input$ratio * input$costT + input$costC)\n      n_T <- input$ratio * n_C\n      total_cost <- input$costT * n_T + input$costC * n_C\n      \n      tagList(\n        withMathJax(),\n        h4(\"Manual Cost Allocation:\"),\n        \n        h5(\"1. Budget Constraint:\"),\n        withMathJax(sprintf(\"$$%d = %d n_T + %d n_C$$\", \n                           input$budget, input$costT, input$costC)),\n        \n        h5(\"2. Fixed Allocation Ratio:\"),\n        withMathJax(sprintf(\"$$r = \\\\frac{n_T}{n_C} = %.3f$$\", input$ratio)),\n        \n        h5(\"3. Sample Sizes:\"),\n        withMathJax(sprintf(\"$$n_C = \\\\frac{\\\\text{budget}}{rc_T + c_C} = \\\\frac{%d}{%.3f \\\\cdot %d + %d} = %.1f$$\",\n                           input$budget, input$ratio, input$costT, input$costC, n_C)),\n        withMathJax(sprintf(\"$$n_T = r \\\\cdot n_C = %.3f \\\\cdot %.1f = %.1f$$\", \n                           input$ratio, n_C, n_T)),\n        \n        h5(\"4. Cost Verification:\"),\n        withMathJax(sprintf(\"$$\\\\text{Total cost} = c_T n_T + c_C n_C = %d \\\\cdot %.1f + %d \\\\cdot %.1f = %d$$\",\n                           input$costT, n_T, input$costC, n_C, total_cost))\n      )\n    }\n  })\n}\n\nshinyApp(ui = ui, server = server)\n","type":"text"}]
